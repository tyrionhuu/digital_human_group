<?xml version="1.0" ?>
<presentation>
  <slide>
    <title>Access methods for time-evolving data</title>
    <content>Access methods for time-evolving dataPresenters : Virag Kothari ,Vandana Ayyalasomayajula                         Date: 04/21/2010</content>
  </slide>
  <slide>
    <title>Outline</title>
    <content>OutlineIntroduction to temporal databasesGoal of the paperAccess method costsQueriesIndex pagination &amp;amp; Data ClusteringEfficient method design for transaction dataReferences</content>
  </slide>
  <slide>
    <title>Introduction</title>
    <content>IntroductionBased on time dimension Transaction time databaseValid time databaseBitemporal database</content>
  </slide>
  <slide>
    <title>Goal</title>
    <content>GoalAttempt to identify the implications for access method design from support of each time dimensionIn this presentation, transaction time databases are considered.</content>
  </slide>
  <slide>
    <title>Access Method Costs </title>
    <content>Access Method Costs Performance of an access method depends on storage space to physically store the data records and the structures of the access methodupdate processing time (the time to update the method’s data structures as a result of a change)the query time for each of the basic queries   ( discussed in the next slide !)</content>
  </slide>
  <slide>
    <title>Queries</title>
    <content>QueriesGiven a contiguous interval T, find all objects alive during this interval.Given a key range and a contiguous time interval T, find the objects with keys in the given range that are alive during interval T.Given a key range, find the history of the objects in this range.</content>
  </slide>
  <slide>
    <title>Queries                   - Special cases !</title>
    <content>Queries                   - Special cases !“transaction pure-timeslice”A special case of class (I) occurs when interval T is reduced to a single transaction time instant t.“transaction range-timeslice”representative case of class (II) where the time interval is reduced to a single transaction time instant.“transaction pure-key query”representative case of class (III), key range is reduced to a single key</content>
  </slide>
  <slide>
    <title>Cost parameters</title>
    <content>Cost parametersIn the case of transaction , Bitemporal databases,n - &amp;gt; summation of insertions, deletions, and modification updates.For Valid time databases,L - &amp;gt; the number of interval objects currently stored in the method, i.e., the size of the collectiona -&amp;gt; to denote the answer size of a query in general.</content>
  </slide>
  <slide>
    <title>Index pagination &amp;amp; Data Clustering</title>
    <content>Index pagination &amp;amp; Data ClusteringCost depends on IO cost !Performance of an index depends on how well it is ‘Paginated’Example: B+ trees.Data Clustering improves performance by storing logically near data , physically close on the disk.pure-timeslice query takes O(logBn + a/B ) page accesses. This method is more I/O efficient than another method that solves the same query in O(logBn + a) page accesses.</content>
  </slide>
  <slide>
    <title>Efficient Method Design for Transaction</title>
    <content>Efficient Method Design for TransactionTransaction Pure-Timeslice Query‘copy’ approachStores a copy of the transaction database state s(t) (timeslice) for each transaction time that at least one change occurredCopies are indexed by time t.‘log’ approachStores only the changes that occur in the database timestamped by the time instant on which they occurred.Copies indexed by time t.</content>
  </slide>
  <slide>
    <title>Comparison       – Transaction pure timeslice</title>
    <content>Comparison       – Transaction pure timeslice</content>
  </slide>
  <slide>
    <title>Transaction Pure Key</title>
    <content>Transaction Pure Key“copy” and “log” solutions could be used for the pure-key query. But they are both very inefficient !!.A better solution is to store the history of each key separately, i.e., cluster data by key only.Access to a key’s (transaction time) history can be implemented by a hashing function  or B tree.The list of versions of each key can be further organized in a separate array indexed by transaction time to answer a pure-key query with time predicate .</content>
  </slide>
  <slide>
    <title>Costs                 – Transaction pure key</title>
    <content>Costs                 – Transaction pure keyCost to index into hash table or B tree + cost of searching in the array.Array length can be n/B , so cost would    O( log B n) .</content>
  </slide>
  <slide>
    <title>Transaction Range-Timeslice</title>
    <content>Transaction Range-TimesliceTo answer a range query efficiently, it is best to cluster by transaction time and key within pages.Very similar to spatial indexing concept.Two dimensions , time &amp;amp; key need to be considered.Data bounding techniqueAnother possibility data mapping, maps a record to three (or more) coordinates –transaction start_time, end-_time, and key(s)—and then uses a  multiattribute point index.</content>
  </slide>
  <slide>
    <title>References</title>
    <content>ReferencesBetty Salzberg, Vassilis J. Tsotras: Comparison of Access Methods forTime-Evolving Data. ACM Comput. Surv. (CSUR) 31(2):158-221 (1999)</content>
  </slide>
  <slide>
    <title/>
    <content>                     Thank you!! </content>
  </slide>
</presentation>
